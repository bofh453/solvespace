//-----------------------------------------------------------------------------
// Data structures used frequently in the program, various kinds of vectors
// (of real numbers, not symbolic algebra stuff) and our templated lists.
//
// Copyright 2008-2013 Jonathan Westhues.
//-----------------------------------------------------------------------------
#ifndef __DSC_H
#define __DSC_H

#include "solvespace.h"

class Vector;
class Vector4;
class Point2d;
class hEntity;
class hParam;

class Quaternion {
public:
    // a + (vx)*i + (vy)*j + (vz)*k
    double w, vx, vy, vz;

    static const Quaternion IDENTITY;

    static Quaternion From(double w, double vx, double vy, double vz);
    static Quaternion From(hParam w, hParam vx, hParam vy, hParam vz);
    static Quaternion From(Vector u, Vector v);
    static Quaternion From(Vector axis, double dtheta);

    Quaternion Plus(Quaternion b);
    Quaternion Minus(Quaternion b);
    Quaternion ScaledBy(double s);
    double Magnitude(void);
    Quaternion WithMagnitude(double s);

    // Call a rotation matrix [ u' v' n' ]'; this returns the first and
    // second rows, where that matrix is generated by this quaternion
    Vector RotationU(void);
    Vector RotationV(void);
    Vector RotationN(void);
    Vector Rotate(Vector p);

    Quaternion ToThe(double p);
    Quaternion Inverse(void);
    Quaternion Times(Quaternion b);
    Quaternion Mirror(void);
};

class Vector {
public:
    double x, y, z;

    static Vector From(double x, double y, double z);
    static Vector From(hParam x, hParam y, hParam z);
    static Vector AtIntersectionOfPlanes(Vector n1, double d1,
                                         Vector n2, double d2);
    static Vector AtIntersectionOfLines(Vector a0, Vector a1,
                                        Vector b0, Vector b1,
                                        bool *skew,
                                        double *pa=NULL, double *pb=NULL);
    static Vector AtIntersectionOfPlaneAndLine(Vector n, double d,
                                               Vector p0, Vector p1,
                                               bool *parallel);
    static Vector AtIntersectionOfPlanes(Vector na, double da,
                                         Vector nb, double db,
                                         Vector nc, double dc, bool *parallel);
    static void ClosestPointBetweenLines(Vector pa, Vector da,
                                         Vector pb, Vector db,
                                         double *ta, double *tb);

    double Element(int i);
    bool Equals(Vector v, double tol=LENGTH_EPS);
    bool EqualsExactly(Vector v);
    Vector Plus(Vector b);
    Vector Minus(Vector b);
    Vector Negated(void);
    Vector Cross(Vector b);
    double DirectionCosineWith(Vector b);
    double Dot(Vector b);
    Vector Normal(int which);
    Vector RotatedAbout(Vector orig, Vector axis, double theta);
    Vector RotatedAbout(Vector axis, double theta);
    Vector DotInToCsys(Vector u, Vector v, Vector n);
    Vector ScaleOutOfCsys(Vector u, Vector v, Vector n);
    double DistanceToLine(Vector p0, Vector dp);
    bool OnLineSegment(Vector a, Vector b, double tol=LENGTH_EPS);
    Vector ClosestPointOnLine(Vector p0, Vector dp);
    double Magnitude(void);
    double MagSquared(void);
    Vector WithMagnitude(double s);
    Vector ScaledBy(double s);
    Vector ProjectInto(hEntity wrkpl);
    Vector ProjectVectorInto(hEntity wrkpl);
    double DivPivoting(Vector delta);
    Vector ClosestOrtho(void);
    void MakeMaxMin(Vector &maxv, Vector &minv);
    Vector ClampWithin(double minv, double maxv);
    static bool BoundingBoxesDisjoint(Vector amax, Vector amin,
                                      Vector bmax, Vector bmin);
    static bool BoundingBoxIntersectsLine(Vector amax, Vector amin,
                                          Vector p0, Vector p1, bool segment);
    bool OutsideAndNotOn(Vector maxv, Vector minv);
    Vector InPerspective(Vector u, Vector v, Vector n,
                         Vector origin, double cameraTan);
    Point2d Project2d(Vector u, Vector v);
    Point2d ProjectXy(void);
    Vector4 Project4d(void);
};

class Vector4 {
public:
    double w, x, y, z;

    static Vector4 From(double w, double x, double y, double z);
    static Vector4 From(double w, Vector v3);
    static Vector4 Blend(Vector4 a, Vector4 b, double t);

    Vector4 Plus(Vector4 b);
    Vector4 Minus(Vector4 b);
    Vector4 ScaledBy(double s);
    Vector PerspectiveProject(void);
};

class Point2d {
public:
    double x, y;

    static Point2d From(double x, double y);

    Point2d Plus(Point2d b);
    Point2d Minus(Point2d b);
    Point2d ScaledBy(double s);
    double DivPivoting(Point2d delta);
    double Dot(Point2d p);
    double DistanceTo(Point2d p);
    double DistanceToLine(Point2d p0, Point2d dp, bool segment);
    double Magnitude(void);
    double MagSquared(void);
    Point2d WithMagnitude(double v);
    Point2d Normal(void);
    bool Equals(Point2d v, double tol=LENGTH_EPS);
};

// A simple list
template <class T>
class List {
public:
    std::vector<T> elem;

    typename std::vector<T>::iterator begin() {
        return elem.begin();
    }

    typename std::vector<T>::iterator end() {
        return elem.end();
    }

    void Add(T &t) {
        elem.push_back(t);
    }

    void AddToBeginning(T &t) {
        elem.push_front(t);
    }

    size_t Size() {
        return elem.size();
    }

    void ClearTags(void) {
        for(T &t : elem)
            t.tag = 0;
    }

    void Clear(void) {
        elem.clear();
    }

    void RemoveTagged(void) {
        auto dest = elem.begin();
        for(T &src : elem) {
            if(!src.tag)
                *dest++ = src;
        }
        elem.resize(dest - elem.begin());
    }

    void RemoveLast(int cnt) {
        elem.resize(elem.length() - cnt);
    }

    void Reverse(void) {
        std::reverse(elem.begin(), elem.end());
    }
};

template <class T>
class VectorPtrIterator : public std::iterator<std::input_iterator_tag, T*>
{
  typename std::vector<T>::iterator _it;
public:
  VectorPtrIterator(typename std::vector<T>::iterator it) : _it(it) {}
  VectorPtrIterator(const VectorPtrIterator& other) : _it(other._it) {}
  VectorPtrIterator& operator++() { ++_it; return *this; }
  VectorPtrIterator operator++(int) { VectorPtrIterator tmp(*this); operator++(); return tmp; }
  bool operator==(const VectorPtrIterator& rhs) { return _it == rhs._it; }
  bool operator!=(const VectorPtrIterator& rhs) { return _it != rhs._it; }
  T* operator*() { return &*_it; }
};

// A list, where each element has an integer identifier. The list is kept
// sorted by that identifier, and items can be looked up in log n time by
// id.
template <class T, class H>
class IdList {
public:
    std::vector<T> elem;

    VectorPtrIterator<T> begin() {
        return VectorPtrIterator<T>(elem.begin());
    }

    VectorPtrIterator<T> end() {
        return VectorPtrIterator<T>(elem.end());
    }

    uint32_t MaximumId(void) {
        uint32_t id = 0;

        for(T &t : elem)
            id = max(id, t.h.v);

        return id;
    }

    H AddAndAssignId(T &t) {
        t.h.v = MaximumId() + 1;
        Add(t);

        return t.h;
    }

    void Add(T &t) {
        auto it = std::lower_bound(elem.begin(), elem.end(), t,
            [](const T& a, const T& b) { return a.h.v < b.h.v; });
        if(it->h.v == t.h.v) {
          dbp("trying to add element twice");
          oops();
        }

        elem.insert(it, t);
    }

    size_t Size() {
        return elem.size();
    }

    T *FindById(H h) {
        T *t = FindByIdNoOops(h);
        if(!t) {
            dbp("failed to look up item %08x, searched %d items", h, elem.size());
            oops();
        }

        return t;
    }

    T *FindByIdNoOops(H h) {
        auto it = std::find_if(elem.begin(), elem.end(),
            [h](const T& t) { return t.h.v == h.v; });
        return (it == elem.end() ? NULL : &*it);
    }

    void ClearTags(void) {
        for(T &t : elem)
            t.tag = 0;
    }

    void Tag(H h, int tag) {
        FindById(h)->tag = tag;
    }

    void RemoveTagged(void) {
        auto dest = elem.begin();
        for(T &src : elem) {
            if(!src.tag)
                *dest++ = src;
        }
        elem.resize(dest - elem.begin());
    }

    template<typename Predicate>
    void RemoveIf(Predicate pred) {
        auto it = std::remove_if(elem.begin(), elem.end(), pred);
        elem.erase(it);
    }

    void RemoveById(H h) {
        RemoveIf([h](const T& t) { return t.h.v == h.v; });
    }

    void MoveSelfInto(IdList<T,H> &other) {
        std::move(elem.begin(), elem.end(), other.elem.begin());
        elem.clear();
    }

    void DeepCopyInto(IdList<T,H> &other) {
        std::copy(elem.begin(), elem.end(), other.elem.begin());
    }

    void Clear(void) {
        elem.clear();
    }
};

class NameStr {
public:
    char str[64];

    inline void strcpy(const char *in) {
        memcpy(str, in, min(strlen(in)+1, sizeof(str)));
        str[sizeof(str)-1] = '\0';
    }
};

class BandedMatrix {
public:
    enum {
        MAX_UNKNOWNS   = 16,
        RIGHT_OF_DIAG  = 1,
        LEFT_OF_DIAG   = 2
    };

    double A[MAX_UNKNOWNS][MAX_UNKNOWNS];
    double B[MAX_UNKNOWNS];
    double X[MAX_UNKNOWNS];
    int n;

    void Solve(void);
};

#define RGBi(r, g, b) RgbColor::From((r), (g), (b))
#define RGBf(r, g, b) RgbColor::FromFloat((float)(r), (float)(g), (float)(b))
#define NULL_COLOR    RgbColor::Default()

// Note: sizeof(class RgbColor) should be exactly 4
//
class RgbColor {
    uint8_t useDefault;
public:
    uint8_t red, green, blue;

    float redF(void)   const { return (float)red   / 255.0f; }
    float greenF(void) const { return (float)green / 255.0f; }
    float blueF(void)  const { return (float)blue  / 255.0f; }

    bool UseDefault(void) const { return useDefault != 0; }

    bool Equals(RgbColor c) const {
        switch(c.useDefault + useDefault) {
            case 0: return
                c.red   == red   &&
                c.green == green &&
                c.blue  == blue;
            case 1: return false;
            case 2: return true;
        }
        return false;
    }

    uint32_t ToPackedInt(void) const {
        return red | (uint32_t)(green << 8) | (uint32_t)(blue << 16);
    }

    static RgbColor Default(void) {
        RgbColor c;
        c.useDefault = 1;
        // Leave r, g, b uninitialized so that Valgrind will notice
        // if they are used inadvertently
        return c;
    }

    static RgbColor From(int r, int g, int b) {
        RgbColor c;
        c.useDefault = 0;
        c.red   = (uint8_t)r;
        c.green = (uint8_t)g;
        c.blue  = (uint8_t)b;
        return c;
    }

    static RgbColor FromFloat(float r, float g, float b) {
        return From(
            (int)(255.1f * r),
            (int)(255.1f * g),
            (int)(255.1f * b));
    }

    static RgbColor FromPackedInt(uint32_t bgr) {
        return From(
            (int)((bgr)       & 0xff),
            (int)((bgr >> 8)  & 0xff),
            (int)((bgr >> 16) & 0xff));
    }
};

#endif
